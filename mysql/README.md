### 1.一条SQL查询语句是如何执行的
1. 链接器 负责跟客户端建立连接、获取权限、维持和管理连接。
2. 查询缓存 关闭缓存：参数 query_cache_type 设置成 DEMAND
3. 分析器 （语法分析、词法分析）
4. 优化器 生成执行计划、索引选择
5. 执行器 执行语句，先判断用户有无查询权限，使用表定义的存储引擎。

### 2. 日志系统：一条SQL更新语句是如何执行的？
#### redo log
* 记录内容：物理日志，记录数据页上所做修改
* 存储方式：空间固定，会重复利用
* innodb 特有日志格式

#### bin log
* 记录内容：逻辑日志，记录语句原始逻辑，记录数据行的变化
* 存储方式：限制单文件大小，达到指定大小后创建新文件存储
* 用途：主从复制、数据恢复、审计

#### update执行过程
1. 根据where条件查找数据行
2. 判断内存中是否存对应数据面
3. 不存在，从硬盘读入内存
4. 存在，返回数据行
5. 修改数据行内容
6. 更新到内存
7. 写入redo log 进入prepare阶段
8. 写入binlog 
9. 提交事务处于commit状态

#### 二阶段提交
1 prepare 阶段   2  写 binlog  3  commit 

* 在2之前崩溃
重启恢复：发现没有commit , 回滚，备份恢复：没有bin log
* 在3之前崩溃
重启恢复：没有commit 但满足prepare和binlog完整，重启后会自动commit，备份恢复：有binlog

### 3.事务隔离：为什么你改了我还看不见？

事务隔离级别|脏读|不可重复读|幻读
--|:--:|--:|--:  
读未提交（read-uncommitted）|是|是|是 
不可重复读（read-committed）|否|是|是
可重复读（repeatable-read）|否|否|是
串行化（serializable）|否|否|否


* 读未提交（read-uncommitted）：可以读取未提交事务的修改
* 不可重复读（read-committed）：一个事务范围内两个相同的查询却返回了不同的数据，造成不可重复读
* 可重复读（repeatable-read）：此模式事务开启时不允许其他事务进行修改操作
* 串行化（serializable）：最高隔离级别，事务顺序执行。
* 脏读：读取到非提交的数据
* 不可重复读：同一事务范围内两个相同的查询却返回不同的数据，造成不可重复读
* 幻读：多读取到删除的数据或少读取到插入的数据

### 4.深入浅出索引
#### 索引的常见模型
* 哈希表，不适合做区间搜索
* 有序数组，只适合静态数据，插入麻烦
* 二叉树搜索树，N叉树

#### innoDB索引模型
主键索引（聚集索引）的叶子节点存储的是整行数据，主键查询主要扫描主键索引
非主键索引（二级索引|非聚集索引）的叶子节点存储主键的值，通过二级查询需要扫描二级索引树，找到主键后再扫描主键索引，该过程叫做回表。

#### 索引维护
因为索引有是有序的，所以推荐使用自增字段做为主键，如无自增主键推荐使用唯一字段做为主键。
#### 索引重建
alter table T engine=InnoDB
不推荐drop，再add。并且不论是删除主键还是创建主键，都会将整个表重建。
#### 覆盖索引
当查询的内容（select 包含的内容）已经在二级索引上时，不需要通过主键回表查询
#### 最左前缀原则
联合索引需合理安排列表的顺序，优先选择选择性高的列放在最左面。可以使用总记录数与列的去重数据项的比值确定选择性。
#### 索引下推
mysql5.6增加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足的记录，减少回表次数。

### 5. 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？
mysql锁的各类：全局锁、表级锁、行级锁
#### 全局锁
使用场景，做逻辑备份

FTWRL命令：Flush tables with read lock;

#### 表级锁
#### 行级锁












































