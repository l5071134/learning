###一条SQL查询语句是如何执行的
1. 链接器 负责跟客户端建立连接、获取权限、维持和管理连接。
2. 查询缓存 关闭缓存：参数 query_cache_type 设置成 DEMAND
3. 分析器 （语法分析、词法分析）
4. 优化器 生成执行计划、索引选择
5. 执行器 执行语句，先判断用户有无查询权限，使用表定义的存储引擎。

### 日志系统：一条SQL更新语句是如何执行的？
#### redo log
* 记录内容：物理日志，记录数据页上所做修改
* 存储方式：空间固定，会重复利用
* innodb 特有日志格式

#### bin log
* 记录内容：逻辑日志，记录语句原始逻辑，记录数据行的变化
* 存储方式：限制单文件大小，达到指定大小后创建新文件存储
* 用途：主从复制、数据恢复、审计

#### update执行过程
1. 根据where条件查找数据行
2. 判断内存中是否存对应数据面
3. 不存在，从硬盘读入内存
4. 存在，返回数据行
5. 修改数据行内容
6. 更新到内存
7. 写入redo log 进入prepare阶段
8. 写入binlog 
9. 提交事务处于commit状态

#### 二阶段提交
1 prepare 阶段   2  写 binlog  3  commit 

* 在2之前崩溃
重启恢复：发现没有commit , 回滚，备份恢复：没有bin log
* 在3之前崩溃
重启恢复：没有commit 但满足prepare和binlog完整，重启后会自动commit，备份恢复：有binlog

###事务隔离：为什么你改了我还看不见？

事务隔离级别|脏读|不可重复读|幻读
--|:--:|--:|--:  
读未提交（read-uncommitted）|是|是|是 
不可重复读（read-committed）|否|是|是
可重复读（repeatable-read）|否|否|是
串行化（serializable）|否|否|否


* 读未提交（read-uncommitted）：可以读取未提交事务的修改
* 不可重复读（read-committed）：一个事务范围内两个相同的查询却返回了不同的数据，造成不可重复读
* 可重复读（repeatable-read）：此模式事务开启时不允许其他事务进行修改操作
* 串行化（serializable）：最高隔离级别，事务顺序执行。
* 脏读：读取到非提交的数据
* 不可重复读：同一事务范围内两个相同的查询却返回不同的数据，造成不可重复读
* 幻读：多读取到删除的数据或少读取到插入的数据




























